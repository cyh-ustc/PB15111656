## Lab1-1 C1语言词法分析

##### PB15111656

#### 实验分析

​	本实验欲用antlr4实现一个C1语言的词法分析器。C1语言是C语言的子集，相比C语言精简的多。特别是其没有字符串，因而词法分析并不复杂。

​	实验的难点在于对注释的识别，C1 语言的注释和 C 语言一致：行注释为//开始，到第一个行尾字符非\的行结束的区域；块注释为从/*开始，到第一个*/处结束的区域。

（个人认为行尾的\应该在预处理阶段处理，而非放在词法分析里。而词法分析不需要考虑行尾\。而且预处理也包括删除注释)

​	比如用`gcc -E 1.c`处理如下代码 (typora高亮有问题)

```c
int ma\
in(){return 0;// \
123456
}
```

结果为

```c
//省略
int main()

{return 0;}
```

#### 实验设计

* 逗号，各类括号，关键字等只需用字符串直接表示即可
* 数字已经给出来了(对八进制数支持不足)：

```
Number: [0-9]+ | '0x' [0-9a-fA-F]+ ;
```

* 标识符按C语言定义为:

```
[A-Za-z_][A-Za-z0-9_]*
```

* 空格、表符、回车和换行一律抛弃

```
WhiteSpace: [ \t\r\n]+ -> skip;
```

* 最终考虑注释

```
BlockComment: '/*' .*? '*/' -> skip;
LineComment: '//' ((~('\r'|'\n'))|'\\\n'|'\\\n\r')* -> skip;
```

#### 实验测试

使用以下5个文件测试

* lex_1.c1 测试各个token

```c
int main()
{
	const int i[] = 0xfff8f8f;
	if(i==0)
	else j
	i = u/1+,z-m%4*4;
	//abcdefl; const void a;/*
	/*asdsdgsdgaadsg//*/
	//;
}
```

* lex_2.c1测试行注释末尾换行

```c
int /*
// helo
\
*/
i = 1 // \
233
           + 44;
int j = // \
; \
; \
; \
;
             3 ;
```

* lex_3.c1测试//与/**/混合

```c
int main()
i = 3 < 2;
i = 3 < = 2;
i = 3 >= 2;
i = 3 > 2;
i + int1 + //  /*
45656/*
645
//*/
```

* lex_4.c1错误的数字错误的标识符

```c
int i = 0xwrongnum;
const1 = 0Xwrong num;
int(){12fn = 2}
```

* lex_5.c1错误的/**/注释

```c
/*
int main()
{
i = 1;
m = 10;
}
```

